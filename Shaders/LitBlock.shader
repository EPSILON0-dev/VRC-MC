Shader "Minecraft/LitBlock"
{
    Properties
    {
        // _BlockPlacementTex ("Block Texture (autogenerated)", 2D) = "white" {}
        _BlockAtlasTex ("Block Texture Atlas", 2DArray) = "" {}
        _SideMappingTex ("Side Mapping Texture", 2D) = "white" {}
        _IndexInParent ("Chunk Index", float) = 0.0
        _Glossiness ("Smoothness", Range(0,1)) = 0.5
        _Metallic ("Metallic", Range(0,1)) = 0.0
        _Color ("Color Tint", Color) = (1,1,1,1)
    }
    SubShader
    {
        Tags { "RenderType"="Cutout" }
        LOD 200

        CGPROGRAM
        #pragma vertex vert
        // Physically based Standard lighting model, and enable shadows on all light types
        #pragma surface surf Standard fullforwardshadows

        // Use shader model 3.0 target, to get nicer looking lighting
        #pragma target 3.0

        UNITY_DECLARE_TEX2D(_BlockPlacementTex);
        UNITY_DECLARE_TEX2DARRAY(_BlockAtlasTex);
        UNITY_DECLARE_TEX2D(_SideMappingTex);
        float _IndexInParent;
        half _Glossiness;
        half _Metallic;
        fixed4 _Color;

        struct Input
        {
            float2 uv_BlockAtlasTex;
            float3 worldNormal;
            float3 worldPos;
            float3 localPos;
        };

        void vert(inout appdata_full v, out Input o) {
            UNITY_INITIALIZE_OUTPUT(Input, o);
            o.localPos = v.vertex.xyz; // vertex position in object (model) space
        }

        void surf (Input IN, inout SurfaceOutputStandard o)
        {
            // Calculate local position from world position (approximate)
            float3 localPos = IN.localPos;

            // Adjust localPos by normal * 0.2 and floor it
            localPos -= IN.worldNormal * 0.2;
            localPos = floor(localPos); 

            // Calculate block texture UVs
            float xPos = localPos.x + localPos.z * 8.0 + fmod(localPos.y, 2.0) * 64.0;
            float yPos = floor(localPos.y / 2.0) + _IndexInParent * 4.0;
            float2 blockUV = float2((xPos + 0.5) / 128.0, (yPos + 0.5) / 128.0);

            // Sample block texture to get block index
            float4 blockSample = UNITY_SAMPLE_TEX2D(_BlockPlacementTex, blockUV);
            float blockIndex = floor(blockSample.r * 255.0 + 0.5);

            // Get the side index from the world normal
            int sideIndex = 0;
            if (abs(IN.worldNormal.x) > 0.5) {
                sideIndex = IN.worldNormal.x > 0.0 ? 3 : 2; // Right : Left
            } else if (abs(IN.worldNormal.y) > 0.5) {
                sideIndex = IN.worldNormal.y > 0.0 ? 4 : 5; // Top : Bottom
            } else if (abs(IN.worldNormal.z) > 0.5) {
                sideIndex = IN.worldNormal.z > 0.0 ? 0 : 1; // Front : Back
            }

            // Sample side mapping texture to get texture index
            float sideULower = (fmod(blockIndex, 8.0) + 0.25) / 8.0;
            float sideUUpper = (fmod(blockIndex, 8.0) + 0.75) / 8.0;
            float sideV = (floor(blockIndex / 8.0) + 0.5) / 16.0;

            float4 sideSampleLower = UNITY_SAMPLE_TEX2D(_SideMappingTex, float2(sideULower, sideV));
            float4 sideSampleUpper = UNITY_SAMPLE_TEX2D(_SideMappingTex, float2(sideUUpper, sideV));
            float sideSample = 0.0;

            // Selectying the correct channel based on sideIndex
            if (sideIndex == 0) {
                sideSample = sideSampleLower.r;
            } else if (sideIndex == 1) {
                sideSample = sideSampleLower.g;
            } else if (sideIndex == 2) {
                sideSample = sideSampleLower.b;
            } else if (sideIndex == 3) {
                sideSample = sideSampleUpper.r;
            } else if (sideIndex == 4) {
                sideSample = sideSampleUpper.g;
            } else if (sideIndex == 5) {
                sideSample = sideSampleUpper.b;
            }

            // Calculate texture index in atlas
            float textureIndex = floor(sideSample * 255.0 + 0.5);

            // Get final UVs for atlas texture
            float3 uvFinal = float3(IN.uv_BlockAtlasTex, textureIndex);

            // Sample atlas texture
            fixed4 atlasSample = UNITY_SAMPLE_TEX2DARRAY(_BlockAtlasTex, uvFinal);

            // Apply color tint
            fixed4 c = atlasSample * _Color;

            // Alpha cutout
            if (c.a < 0.5)
                discard;

            o.Albedo = c.rgb;
            o.Metallic = _Metallic;
            o.Smoothness = _Glossiness;
            o.Alpha = c.a;
        }
        ENDCG
    }
    FallBack "Diffuse"
}
